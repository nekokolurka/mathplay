#include<locale.h>
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
void ZAPZN(char*, int, int);
//функция заполенения массива знаков
void ZAPZN(char* ZNAK, int kol, int skob)
{
    int sk = skob;
    for (int i = ((kol - 2) - skob); i >= 1; i -= 2)//от (количества символов-количество скобок) заполняем через каждые две ячейки, так как помимо знаков одновременно вставляются еще и скобки
    {
        int c = 1 + rand() % 5;//генерируется случайное число от 1 до 5, а потом в зависимости от числа в ячейку массива вставляется один из 5 знаков и скобка в конец цепочки и в перед знаком
        if (c == 1) { ZNAK[i] = '+'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 2) { ZNAK[i] = '-'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 3) { ZNAK[i] = '*'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 4) { ZNAK[i] = '/'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 5) { ZNAK[i] = '^'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
    }
}
void PREOBRAZ(char*, int, int*, int*);
//функция-преобразователь массива знаков. в зависимости от приоритета убираются лишние скобки, 
//переменная отвечающая за скобки передана как указатель, чтобы менять ее и в мейне
void PREOBRAZ(char* VIR, int kol, int* skob, int* nuli)
{
int i;
    for (i = ((kol - 2) - (*skob)); i >= 3; i -= 2)//начиная с самого последнего знака(не считая скобки) цикл бежит по знакам до 2 с начала
    {
	//в зависимости от приоритетности каждый знак сравнивается с предыдущим, чтобы понять, нужно убирать скобки или нет,
	//если скобки не нужны, они обнуляются, как открывающаяся так и закрывающаяся
        if ((VIR[i] == '+') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/' && VIR[i - 2] != '-') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '-') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/' && VIR[i - 2] != '-') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '*') && VIR[i - 2] != '^' && VIR[i - 2] != '/') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '/') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
    }
if (i == 1 && VIR[i - 1] == '(') { VIR[i - 1] = '0'; VIR[kol - 2] = '0'; (*skob)--; }//перед самым первым знаком скобка не обязательна, поэтому она убирается 
    int d = kol - 2;
    while (d != 0)//данный цикл сдвигает все нули в конец, чтобы потом уменьшить размерность массива, чтобы он не занимал память
    {
        for (i = 1; i <= (kol - 2); i++)
        {

            if (VIR[i - 1] == '0')
            {
                VIR[i - 1] = VIR[i];
                VIR[i] = '0';
            }
        }
        d--;
    }
    for (i = 1; i <= (kol - 2); i++) { if (VIR[i] == '0') (*nuli)++; }
	//данный цикл считает количество нулей, чтобы после можно было уменьшить размерность массива на правильное кол-во знаков
}
void VIVOD(char*, int*, int);
//данная функция, это функция вывода. единственная ее функция - вывести на экран цельное получившееся выражение,
//которое на самом деле состоит из двух массивов - знаков и чисел
void VIVOD(char* VIR, int* CHIS, int kol)
{
    int j = 0, i;
    for (i = 0; i < kol - 1; i++)//данный цикл, в опредленном порядке выводит элементы массива знаков и массива чисел
    {
	//отличительная особенность данного вывода в том, что если считываемое число оказалось отрицательным, оно берется в скобки, чтобы было понятно, что минус относится конкретно к числу
        if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] != ')' && CHIS[j] > 0) { printf("%d%c", CHIS[j], VIR[i]); j++; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] != ')' && CHIS[j] < 0) { printf("(%d)%c", CHIS[j], VIR[i]); j++; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] > 0 && CHIS[j + 1] > 0) { printf("%d%c%d%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] < 0 && CHIS[j + 1]>0) { printf("(%d)%c%d%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] > 0 && CHIS[j + 1] < 0) { printf("%d%c(%d)%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] < 0 && CHIS[j + 1] < 0) { printf("(%d)%c(%d)%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] == '(') printf("%c", VIR[i]);
        else if (VIR[i] == ')' && VIR[i - 1] == ')') printf("%c", VIR[i]);
        if (i == kol - 2 && VIR[i] != '(' && VIR[i] != ')' && CHIS[j] > 0) printf("%d", CHIS[j]);
        else if (i == kol - 2 && VIR[i] != '(' && VIR[i] != ')' && CHIS[j] < 0) printf("(%d)", CHIS[j]);
    }
    printf("\n");
}
float SCHET(char*, int*, int, int, int);
//данная функция отвечает за вычисление всего выражения
float SCHET(char* VIR, int* CHIS, int kol, int skob, int chis)
{
    int i = kol, j = chis - 2;
    float schet = (float)CHIS[chis - 1];

    for (i = kol; i >= 0; i--)//алгоритм вычисления достаточно простой, просто проверка знаков и соответствующие им действия
    {
        if (VIR[i] == '^')
        {
            schet = pow((float)CHIS[j], schet); j--;
        }
        else if (VIR[i] == '*')
        {
            schet = (float)CHIS[j] * schet; j--;
        }
        else if (VIR[i] == '/')
        {
            schet = (float)CHIS[j] / schet; j--;
        }
        else if (VIR[i] == '-')
        {
            schet = CHIS[j] - schet; j--;
        }
        else if (VIR[i] == '+')
        {
            schet = CHIS[j] + schet; j--;
        }

    }

    return schet;
