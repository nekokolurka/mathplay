#include<locale.h>
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
void ZAPZN(char*, int, int);
//функция заполенения массива знаков
void ZAPZN(char* ZNAK, int kol, int skob)
{
    int sk = skob;
    for (int i = ((kol - 2) - skob); i >= 1; i -= 2)//от (количества символов-количество скобок) заполняем через каждые две ячейки, так как помимо знаков одновременно вставляются еще и скобки
    {
        int c = 1 + rand() % 5;//генерируется случайное число от 1 до 5, а потом в зависимости от числа в ячейку массива вставляется один из 5 знаков и скобка в конец цепочки и в перед знаком
        if (c == 1) { ZNAK[i] = '+'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 2) { ZNAK[i] = '-'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 3) { ZNAK[i] = '*'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 4) { ZNAK[i] = '/'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
        else if (c == 5) { ZNAK[i] = '^'; ZNAK[(kol - 2) - sk + 1] = ')'; sk--; ZNAK[i - 1] = '('; }
    }
}
void PREOBRAZ(char*, int, int*, int*);
//функция-преобразователь массива знаков. в зависимости от приоритета убираются лишние скобки, 
//переменная отвечающая за скобки передана как указатель, чтобы менять ее и в мейне
void PREOBRAZ(char* VIR, int kol, int* skob, int* nuli)
{
int i;
    for (i = ((kol - 2) - (*skob)); i >= 3; i -= 2)//начиная с самого последнего знака(не считая скобки) цикл бежит по знакам до 2 с начала
    {
	//в зависимости от приоритетности каждый знак сравнивается с предыдущим, чтобы понять, нужно убирать скобки или нет,
	//если скобки не нужны, они обнуляются, как открывающаяся так и закрывающаяся
        if ((VIR[i] == '+') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/' && VIR[i - 2] != '-') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '-') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/' && VIR[i - 2] != '-') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '*') && VIR[i - 2] != '^' && VIR[i - 2] != '/') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
        else if ((VIR[i] == '/') && VIR[i - 2] != '^' && VIR[i - 2] != '*' && VIR[i - 2] != '/') { VIR[(kol - 2) - (*skob) + 1] = '0'; VIR[i - 1] = '0'; (*skob)--; }
    }
if (i == 1 && VIR[i - 1] == '(') { VIR[i - 1] = '0'; VIR[kol - 2] = '0'; (*skob)--; }//перед самым первым знаком скобка не обязательна, поэтому она убирается 
    int d = kol - 2;
    while (d != 0)//данный цикл сдвигает все нули в конец, чтобы потом уменьшить размерность массива, чтобы он не занимал память
    {
        for (i = 1; i <= (kol - 2); i++)
        {

            if (VIR[i - 1] == '0')
            {
                VIR[i - 1] = VIR[i];
                VIR[i] = '0';
            }
        }
        d--;
    }
    for (i = 1; i <= (kol - 2); i++) { if (VIR[i] == '0') (*nuli)++; }
	//данный цикл считает количество нулей, чтобы после можно было уменьшить размерность массива на правильное кол-во знаков
}
void VIVOD(char*, int*, int);
//данная функция, это функция вывода. единственная ее функция - вывести на экран цельное получившееся выражение,
//которое на самом деле состоит из двух массивов - знаков и чисел
void VIVOD(char* VIR, int* CHIS, int kol)
{
    int j = 0, i;
    for (i = 0; i < kol - 1; i++)//данный цикл, в опредленном порядке выводит элементы массива знаков и массива чисел
    {
	//отличительная особенность данного вывода в том, что если считываемое число оказалось отрицательным, оно берется в скобки, чтобы было понятно, что минус относится конкретно к числу
        if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] != ')' && CHIS[j] > 0) { printf("%d%c", CHIS[j], VIR[i]); j++; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] != ')' && CHIS[j] < 0) { printf("(%d)%c", CHIS[j], VIR[i]); j++; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] > 0 && CHIS[j + 1] > 0) { printf("%d%c%d%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] < 0 && CHIS[j + 1]>0) { printf("(%d)%c%d%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] > 0 && CHIS[j + 1] < 0) { printf("%d%c(%d)%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] != '(' && VIR[i] != ')' && VIR[i + 1] == ')' && CHIS[j] < 0 && CHIS[j + 1] < 0) { printf("(%d)%c(%d)%c", CHIS[j], VIR[i], CHIS[j + 1], VIR[i + 1]); i++; j += 2; }
        else if (VIR[i] == '(') printf("%c", VIR[i]);
        else if (VIR[i] == ')' && VIR[i - 1] == ')') printf("%c", VIR[i]);
        if (i == kol - 2 && VIR[i] != '(' && VIR[i] != ')' && CHIS[j] > 0) printf("%d", CHIS[j]);
        else if (i == kol - 2 && VIR[i] != '(' && VIR[i] != ')' && CHIS[j] < 0) printf("(%d)", CHIS[j]);
    }
    printf("\n");
}
float SCHET(char*, int*, int, int, int);
//данная функция отвечает за вычисление всего выражения
float SCHET(char* VIR, int* CHIS, int kol, int skob, int chis)
{
    int i = kol, j = chis - 2;
    float schet = (float)CHIS[chis - 1];

    for (i = kol; i >= 0; i--)//алгоритм вычисления достаточно простой, просто проверка знаков и соответствующие им действия
    {
        if (VIR[i] == '^')
        {
            schet = pow((float)CHIS[j], schet); j--;
        }
        else if (VIR[i] == '*')
        {
            schet = (float)CHIS[j] * schet; j--;
        }
        else if (VIR[i] == '/')
        {
            schet = (float)CHIS[j] / schet; j--;
        }
        else if (VIR[i] == '-')
        {
            schet = CHIS[j] - schet; j--;
        }
        else if (VIR[i] == '+')
        {
            schet = CHIS[j] + schet; j--;
        }

    }

    return schet;
}
int main()
{
    setlocale(LC_ALL, "ru");//данная функция нужна для русификации текста и особой роли не играет
    int i, j = 0, chisl, skob = 0, jach = 0, nuli = 0, a, b, ball = 0, proverka, itog2;
    int vib = 10;
    float itog;
    srand(time(NULL));
    while (vib != 0 && ball <= 1000)//данный цикл будет работать, пока пользователь не захочет закончить игру, либо пока не наберет 1000 быллов
    {
        if (ball > 0) printf("\tКоличество ваших баллов: %d\n", ball);//после каждого решенного уравнения пользователь будет видеть количество набранных баллов
        else printf("\tПока у вас нет баллов :(\n");
        printf("Чтобы прочитать правила игры нажмите :3\nЕсли хотите задать количество чисел вручную нажмите :1\nЕсли хотите, чтобы количество чисел было задано случайно, нажмите :2\nЕсли хотите завершить программу, нажмите :0\n");
        scanf("%d", &vib);//для начала узнается то, какое количество чисел будет задано - вручную или рандомное количество, либо же пользователь завершит программу
        switch (vib)
        {
        case 1://данный кейс будет работать, если пользователь задает количество чисел сам
            printf("Если хотите задать диапазон чисел вручную, нажмите :1\nЕсли хотите выбрать стандартный диапазон(от 1 до 10 включеительно) нажмите :2\n");
            scanf("%d", &vib);//а здесь считывается то, какой будет использован диапазон значений
            if (vib == 1)//это условие отвечает за введенное вручную кол-во чисел и введенный вручную диапазон
            {
                printf("Введите диапазон от:"); scanf("%d", &a);
                printf("До:"); scanf("%d", &b);
                if (a > b) { printf("Задан неверный дипазон!\n\n"); }//проверка на ошибку и вывод сообщения о ней, если она все же произошла
                else
                {
                    printf("Введите количество чисел:"); scanf("%d", &chisl);
                    if (chisl <= 1) printf("Введено недопустимое количество чисел!\n\n");
                    else
                    {
                        printf("\n");
                        int* CHIS = (int*)malloc(chisl * sizeof(int));//выделяется память под массив чисел
                        ZAPCH(CHIS, chisl, a, b);//массив чисел заполняется в соответствии с даипазоном
                        skob = chisl - 1;//назначается максимально возможное кол-во закрытых скобок для выражения
                        jach = (chisl - 1) * 3 + 1;//определяется количество ячеек в соответствии с количеством чисел
                        char* VIR = (char*)malloc(jach * sizeof(char));//выделяется память под массив знаков
                        ZAPZN(VIR, jach, skob);//массив знаков заполняется
                        PREOBRAZ(VIR, jach, &skob, &nuli);//и преобразовывается
                        jach = (chisl - 1) * 3 + 1 - nuli;//количество ячеек меняется в зависимости от того, сколько образовалось нулей после преобразования
                        nuli = 0;//количество нулей обнуляется
                        VIR = (char*)realloc(VIR, jach * sizeof(char));//уменьшение длинны массива до нового количества ячеек
                        VIR[jach - 1] = '\0';//из массива символов делаем строку
                        VIVOD(VIR, CHIS, jach);//выводим на экран выражение
                        itog = SCHET(VIR, CHIS, jach - 2 - skob, skob, chisl);//считаем наше выражение
                        free(CHIS);//освобождаем память выделенную под массив чисел
                        free(VIR);//освобождаем память выделенную под массив знаков
                        itog2 = (int)itog;//округляем ответ до целого
                        if (itog < 10000 && itog>-10000)//если ответ получился достаточно считаемым для челоека, то...
                        {
                            printf("=%f  %d\n\n", itog, (int)itog);//данная строка нужна для проверки правильности вычисления, однако ее можно закомментировать, дабы пользователь не видел ответ
                            printf("Введите свой ответ(округлите до целого, если получилось не целое число):\n"); scanf("%d", &proverka);
							//пользователю предлагается ввести ответ, если он угадал, ему начисляются баллы, если нет - отнимаются
                            if (proverka == itog2)
                            {
                                printf("Правильно! Вам начислено 100 баллов!\n\n");
                                ball += 100;
                            }
                            else if (proverka != itog2)
                            {
                                printf("Увы, Вы ошиблись :( С Вас снимаются 50 баллов\n\n");
                                ball -= 50;
                            }
                        }
                        else if (itog > 10000)printf("Значение выражения вышло слишком большим, попробуйте еще раз!\n\n");
                        else if (itog < 10000)printf("Значение выражения вышло слишком маленьким, попробуйте еще раз!\n\n");
						//если получислось так, что ответ оказался слишком большим или слишком маленьким(трудным для вычисления)
						//пользователю выводится уведомление об этом и баллы не снимаются
                    }
                }
                
            }
            else if (vib == 2)//это условие отвечает за введенное вручную кол-во чисел и выбранный стандартный диапазон
            {
                a = 1; b = 10;//переменным отвечающим за диапазон присваиваем стандартные значения, далее алгоритм не отличается от vib==1
                printf("Введите количество чисел:"); scanf("%d", &chisl);
                printf("\n");
                if (chisl <= 1) printf("Введено недопустимое количество чисел!\n\n");
                else
                {
                    int* CHIS = (int*)malloc(chisl * sizeof(int));
                    ZAPCH(CHIS, chisl, a, b);
                    skob = chisl - 1;
                    jach = (chisl - 1) * 3 + 1;
                    char* VIR = (char*)malloc(jach * sizeof(char));
                    ZAPZN(VIR, jach, skob);
                    PREOBRAZ(VIR, jach, &skob, &nuli);
                    jach = (chisl - 1) * 3 + 1 - nuli;
                    nuli = 0;
                    VIR = (char*)realloc(VIR, jach * sizeof(char));
                    VIR[jach - 1] = '\0';
                    VIVOD(VIR, CHIS, jach);
                    itog = SCHET(VIR, CHIS, jach - 2 - skob, skob, chisl);
                    free(CHIS);
                    free(VIR);
                    itog2 = (int)itog;
                    if (itog < 10000 && itog>-10000)
                    {
                        printf("=%f  %d\n\n", itog, (int)itog);
                        printf("Введите свой ответ(округлите до целого, если получилось не целое число):\n"); scanf("%d", &proverka);
                        if (proverka == itog2)
                        {
                            printf("Правильно! Вам начислено 150 баллов!\n\n");
                            ball += 150;
                        }
                        else if (proverka != itog2)
                        {
                            printf("Увы, Вы ошиблись :( С Вас снимаются 50 баллов\n\n");
                            ball -= 50;
                        }
                    }
                    else if (itog > 10000)printf("Значение выражения вышло слишком большим, попробуйте еще раз!\n\n");
                    else if (itog < 10000)printf("Значение выражения вышло слишком маленьким, попробуйте еще раз!\n\n");
                }
            }
            else if (vib != 1 || vib != 2) printf("Такой операции не существует, попробуйте еще раз!\n\n");//если пользователь ввел несуществующую операцию, на экран выведется сообщение об этом
            break;
 	case 2://данный кейс будет работать, если пользователь выберет случайное кол-во чисел,
		//алгоритм вычисления выражения в нем почти не отличается от 1 кейса, однако есть пару нюансов которые далее будут закомментированны
            printf("Если хотите задать диапазон чисел вручную, нажмите :1\nЕсли хотите выбрать стандартный диапазон(от 1 до 10 включеительно) нажмите :2\n");
            scanf("%d", &vib);
            if (vib == 1)
            {
                printf("Введите диавпазон от:"); scanf("%d", &a);
                printf("До:"); scanf("%d", &b); printf("\n");
                if (a > b) { printf("Задан неверный дипазон!\n\n"); }
                else
                {
                    chisl = 2 + rand() % 9;//данная строка отвечает за генерацию количества чисел, могут сгенерироваться от 2 до 10 чисел, от 2 лишь потому,
					//что генерация от меньшего значения была бы бессмысленной
                    int* CHIS = (int*)malloc(chisl * sizeof(int));
                    ZAPCH(CHIS, chisl, a, b);
                    skob = chisl - 1;
                    jach = (chisl - 1) * 3 + 1;
                    char* VIR = (char*)malloc(jach * sizeof(char));
                    ZAPZN(VIR, jach, skob);
                    PREOBRAZ(VIR, jach, &skob, &nuli);
                    jach = (chisl - 1) * 3 + 1 - nuli;
                    nuli = 0;
                    VIR = (char*)realloc(VIR, jach * sizeof(char));
                    VIR[jach - 1] = '\0';
                    VIVOD(VIR, CHIS, jach);
                    itog = SCHET(VIR, CHIS, jach - 2 - skob, skob, chisl);
                    free(CHIS);
                    free(VIR);
                    itog2 = (int)itog;
                    if (itog < 10000 && itog>-10000)
